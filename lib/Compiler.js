// Generated by CoffeeScript 1.6.3
(function() {
  var BaseCompiler, Cache, Compiler, FileStorage, Finder, HttpGetException, InvalidArgumentException, Q, fs, http, https, path;

  path = require('path');

  Q = require('q');

  fs = require('fs');

  Cache = require('cache-storage');

  FileStorage = require('cache-storage/Storage/FileStorage');

  Finder = require('fs-finder');

  http = require('http');

  https = require('https');

  BaseCompiler = require('./Compilers/Compiler');

  HttpGetException = require('./Exceptions/HttpGetException');

  InvalidArgumentException = require('./Exceptions/InvalidArgumentException');

  Compiler = (function() {
    var CACHE_NAMESPACE;

    CACHE_NAMESPACE = 'source_compiler';

    Compiler.prototype.cache = null;

    Compiler.prototype.compilers = null;

    function Compiler() {
      this.compilers = {};
      this.addCompiler('coffee', new (require('./Compilers/CoffeeScript')));
      this.addCompiler('eco', new (require('./Compilers/Eco')));
      this.addCompiler('js', new (require('./Compilers/Js')));
      this.addCompiler('json', new (require('./Compilers/Json')));
      this.addCompiler('less', new (require('./Compilers/Less')));
      this.addCompiler('scss', new (require('./Compilers/Scss')));
      this.addCompiler('styl', new (require('./Compilers/Styl')));
      this.addCompiler('ts', new (require('./Compilers/Ts')));
    }

    Compiler.prototype.addCompiler = function(name, compiler) {
      if (!(compiler instanceof BaseCompiler)) {
        throw new InvalidArgumentException('Compiler must be an instance of Compilers/Compiler.');
      }
      this.compilers[name] = compiler;
      return this;
    };

    Compiler.prototype.hasCompiler = function(name) {
      return typeof this.compilers[name] !== 'undefined';
    };

    Compiler.prototype.getCompiler = function(name) {
      if (this.hasCompiler(name)) {
        return this.compilers[name];
      } else {
        return null;
      }
    };

    Compiler.prototype.setCache = function(_path) {
      return this.cache = new Cache(new FileStorage(_path), this.CACHE_NAMESPACE);
    };

    Compiler.prototype.setCacheStorage = function(storage) {
      return this.cache = new Cache(storage, this.CACHE_NAMESPACE);
    };

    Compiler.prototype.isSupported = function(type) {
      return this.hasCompiler(type);
    };

    Compiler.prototype.isRemote = function(_path) {
      return _path.match(/^https?\:\/\//) !== null;
    };

    Compiler.prototype.getType = function(_path) {
      return path.extname(_path).replace(/^\./, '');
    };

    Compiler.prototype.loadFile = function(type, _path, options) {
      var deferred, protocol,
        _this = this;
      deferred = Q.defer();
      if (this.isRemote(_path)) {
        protocol = _path.match(/^https/) ? https : http;
        protocol.get(_path, function(res) {
          var data;
          data = '';
          res.setEncoding('utf-8');
          res.on('data', function(chunk) {
            return data += chunk;
          });
          return res.on('end', function() {
            return _this.compile(type, data, options).then(function(data) {
              return deferred.resolve(data);
            }).fail(function(err) {
              return deferred.reject(err);
            });
          });
        }).on('error', function(e) {
          return deferred.reject(new HttpGetException(e));
        });
      } else {
        fs.readFile(_path, {
          encoding: 'utf-8'
        }, function(err, data) {
          if (err) {
            return deferred.reject(err);
          } else {
            return _this.compile(type, data, options).then(function(data) {
              return deferred.resolve(data);
            }).fail(function(err) {
              return deferred.reject(err);
            });
          }
        });
      }
      return deferred.promise;
    };

    Compiler.prototype.compileFile = function(_path, options) {
      var deferred, result, type,
        _this = this;
      if (options == null) {
        options = {};
      }
      if (!this.isRemote(_path)) {
        _path = path.resolve(_path);
      }
      type = this.getType(_path);
      if (!this.isRemote(_path)) {
        options.path = _path;
      }
      deferred = Q.defer();
      if (this.cache === null || (this.getCompiler(type).isCachableWithDependencies() && typeof options.dependents === 'undefined') || this.isRemote(_path)) {
        this.loadFile(type, _path, options).then(function(data) {
          return deferred.resolve(data);
        }, function(err) {
          return deferred.reject(err);
        });
      } else {
        result = this.cache.load(_path);
        options.dependents = typeof options.dependents === 'undefined' ? [_path] : options.dependents.concat([_path]);
        options.dependents = this.parseDependents(options.dependents);
        if (result === null) {
          this.loadFile(type, _path, options).then(function(data) {
            _this.cache.save(_path, data, {
              files: options.dependents
            });
            return deferred.resolve(data);
          }, function(err) {
            return deferred.reject(err);
          });
        } else {
          deferred.resolve(result);
        }
      }
      return deferred.promise;
    };

    Compiler.prototype.compile = function(type, data, options) {
      var deferred,
        _this = this;
      if (options == null) {
        options = {};
      }
      if (typeof options.path === 'undefined') {
        options.path = null;
      }
      if (typeof options.minify === 'undefined') {
        options.minify = false;
      }
      if (typeof options.debug === 'undefined') {
        options.debug = false;
      }
      if (typeof options.precompile === 'undefined') {
        options.precompile = false;
      }
      if (typeof options.jquerify === 'undefined') {
        options.jquerify = false;
      }
      if (typeof options.data === 'undefined') {
        options.data = {};
      }
      if (typeof options.dependents === 'undefined') {
        options.dependents = [];
      }
      if (!this.hasCompiler(type)) {
        return Q.reject(new InvalidArgumentException("Type " + type + " is not supported."));
      }
      deferred = Q.defer();
      this.getCompiler(type).parse(data, options).then(function(data) {
        var minifier;
        if (options.minify) {
          minifier = _this.getCompiler(type).getMinifier(options);
          data = BaseCompiler.minify[minifier](data);
        }
        return deferred.resolve(data);
      }, function(err) {
        return deferred.reject(err);
      });
      return deferred.promise;
    };

    Compiler.prototype.parseDependents = function(dependents) {
      var result, _i, _len, _path;
      result = [];
      for (_i = 0, _len = dependents.length; _i < _len; _i++) {
        _path = dependents[_i];
        if (_path.match(/^http/) !== null) {
          result.push(_path);
        } else if (fs.existsSync(_path) && fs.statSync(_path).isFile()) {
          result.push(_path);
        } else {
          result = result.concat(Finder.findFiles(_path));
        }
      }
      return result;
    };

    return Compiler;

  })();

  module.exports = new Compiler;

}).call(this);
