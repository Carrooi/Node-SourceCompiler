// Generated by CoffeeScript 1.6.3
(function() {
  var Cache, Compiler, FileStorage, Finder, Q, cleanCss, coffee, eco, exec, fs, http, https, less, path, sass, stylus, uglify,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  path = require('path');

  Q = require('q');

  fs = require('fs');

  coffee = require('coffee-script');

  less = require('less');

  stylus = require('stylus');

  sass = require('node-sass');

  eco = require('eco');

  uglify = require('uglify-js');

  cleanCss = require('clean-css');

  exec = require('child_process').exec;

  Cache = require('cache-storage');

  FileStorage = require('cache-storage/Storage/FileStorage');

  Finder = require('fs-finder');

  http = require('http');

  https = require('https');

  Compiler = (function() {
    var _this = this;

    function Compiler() {}

    Compiler.CACHE_NAMESPACE = 'source_compiler';

    Compiler.cache = null;

    Compiler.minifiers = {
      coffee: 'uglify',
      json: 'uglify',
      js: 'uglify',
      ts: 'uglify',
      less: 'cleanCss',
      scss: 'cleanCss',
      styl: 'cleanCss',
      eco: 'uglify'
    };

    Compiler.cachableWithDeps = ['less', 'scss', 'styl'];

    Compiler.setCache = function(_path) {
      return this.cache = new Cache(new FileStorage(_path), this.CACHE_NAMESPACE);
    };

    Compiler.setCacheStorage = function(storage) {
      return this.cache = new Cache(storage, this.CACHE_NAMESPACE);
    };

    Compiler.isSupported = function(type) {
      return typeof this._compilers[type] !== 'undefined';
    };

    Compiler.isRemote = function(_path) {
      return _path.match(/^https?\:\/\//) !== null;
    };

    Compiler.getType = function(_path) {
      return path.extname(_path).replace(/^\./, '');
    };

    Compiler.loadFile = function(type, _path, options) {
      var deferred, protocol,
        _this = this;
      deferred = Q.defer();
      if (this.isRemote(_path)) {
        protocol = _path.match(/^https/) ? https : http;
        protocol.get(_path, function(res) {
          var data;
          data = '';
          res.setEncoding('utf-8');
          res.on('data', function(chunk) {
            return data += chunk;
          });
          return res.on('end', function() {
            return _this.compile(type, data, options).then(function(data) {
              return deferred.resolve(data);
            });
          });
        }).on('error', function(e) {
          return deferred.reject(new Error(e));
        });
      } else {
        fs.readFile(_path, {
          encoding: 'utf-8'
        }, function(err, data) {
          if (err) {
            return deferred.reject(err);
          } else {
            return _this.compile(type, data, options).then(function(data) {
              return deferred.resolve(data);
            });
          }
        });
      }
      return deferred.promise;
    };

    Compiler.compileFile = function(_path, options) {
      var deferred, result, type,
        _this = this;
      if (options == null) {
        options = {};
      }
      if (!this.isRemote(_path)) {
        _path = path.resolve(_path);
      }
      type = this.getType(_path);
      if (!this.isRemote(_path)) {
        options.path = _path;
      }
      deferred = Q.defer();
      if (this.cache === null || __indexOf.call(this.cachableWithDeps, type) >= 0 && typeof options.dependents === 'undefined' || this.isRemote(_path)) {
        this.loadFile(type, _path, options).then(function(data) {
          return deferred.resolve(data);
        }, function(err) {
          return deferred.reject(err);
        });
      } else {
        result = this.cache.load(_path);
        options.dependents = typeof options.dependents === 'undefined' ? [_path] : options.dependents.concat([_path]);
        options.dependents = this._parseDependents(options.dependents);
        if (result === null) {
          this.loadFile(type, _path, options).then(function(data) {
            _this.cache.save(_path, data, {
              files: options.dependents
            });
            return deferred.resolve(data);
          }, function(err) {
            return deferred.reject(err);
          });
        } else {
          deferred.resolve(result);
        }
      }
      return deferred.promise;
    };

    Compiler.compile = function(type, data, options) {
      var deferred,
        _this = this;
      if (options == null) {
        options = {};
      }
      if (typeof options.path === 'undefined') {
        options.path = null;
      }
      if (typeof options.minify === 'undefined') {
        options.minify = false;
      }
      if (typeof options.debug === 'undefined') {
        options.debug = false;
      }
      if (typeof options.precompile === 'undefined') {
        options.precompile = false;
      }
      if (typeof options.jquerify === 'undefined') {
        options.jquerify = false;
      }
      if (typeof options.data === 'undefined') {
        options.data = {};
      }
      if (typeof options.dependents === 'undefined') {
        options.dependents = [];
      }
      if (!this.isSupported(type)) {
        return Q.reject(new Error("Type '" + type + "' is not supported"));
      }
      deferred = Q.defer();
      this._compilers[type](data, options).then(function(data) {
        if (options.minify) {
          data = _this._minify[_this.minifiers[type]](data);
        }
        return deferred.resolve(data);
      }, function(err) {
        return deferred.reject(err);
      });
      return deferred.promise;
    };

    Compiler._parseDependents = function(dependents) {
      var result, _i, _len, _path;
      result = [];
      for (_i = 0, _len = dependents.length; _i < _len; _i++) {
        _path = dependents[_i];
        if (fs.existsSync(_path) && fs.statSync(_path).isFile()) {
          result.push(_path);
        } else {
          result = result.concat(Finder.findFiles(_path));
        }
      }
      return result;
    };

    Compiler._compilers = {
      coffee: function(data, options) {
        var deferred, err, setup;
        setup = {
          literate: false
        };
        if (options.path !== null) {
          setup.filename = options.path;
        }
        deferred = Q.defer();
        try {
          deferred.resolve(coffee.compile(data, setup));
        } catch (_error) {
          err = _error;
          deferred.reject(Compiler._errors.coffee(err, options.path));
        }
        return deferred.promise;
      },
      json: function(data, options) {
        var deferred;
        deferred = Q.defer();
        deferred.resolve("(function() {\nreturn " + data + "\n}).call(this);\n");
        return deferred.promise;
      },
      js: function(data, options) {
        return Q.resolve(data);
      },
      ts: function(data, options) {
        var deferred, dir, fileName, name, ts;
        if (options.path === null) {
          return Q.reject(new Error('You have to set path for compiling typescript'));
        }
        deferred = Q.defer();
        dir = path.dirname(options.path);
        name = path.basename(options.path, path.extname(options.path));
        fileName = "" + dir + "/" + name + ".js";
        ts = path.resolve("" + __dirname + "/../node_modules/typescript/bin/tsc.js");
        exec("node " + ts + " " + options.path, function(err, stdout, stderr) {
          if (err) {
            return deferred.reject(Compiler._errors.ts(err, options.path));
          } else {
            return fs.readFile(fileName, 'utf-8', function(err, content) {
              fs.unlink(fileName);
              if (err) {
                return deferred.reject(err);
              } else {
                return deferred.resolve(content);
              }
            });
          }
        });
        return deferred.promise;
      },
      less: function(data, options) {
        var deferred, err, setup;
        setup = {
          optimization: 1,
          rootpath: '',
          relativeUrls: false,
          strictImports: false
        };
        if (options.path !== null) {
          setup.paths = [path.dirname(options.path)];
          setup.filename = options.path;
        }
        if (options.debug === true) {
          setup.dumpLineNumbers = 'mediaquery';
        }
        deferred = Q.defer();
        try {
          less.render(data, setup, function(err, data) {
            if (err) {
              return deferred.reject(Compiler._errors.less(err, options.path));
            } else {
              return deferred.resolve(data);
            }
          });
        } catch (_error) {
          err = _error;
          deferred.reject(Compiler._errors.less(err, options.path));
        }
        return deferred.promise;
      },
      scss: function(data, options) {
        var deferred, err, setup;
        deferred = Q.defer();
        setup = {
          data: data
        };
        if (options.path !== null) {
          setup.includePaths = [path.dirname(options.path)];
        }
        try {
          data = sass.renderSync(setup);
          deferred.resolve(data);
        } catch (_error) {
          err = _error;
          deferred.reject(Compiler._errors.scss(err, options.path));
        }
        return deferred.promise;
      },
      styl: function(data, options) {
        var deferred, styl;
        deferred = Q.defer();
        styl = stylus(data);
        if (options.path !== null) {
          styl.include(path.dirname(options.path));
        }
        styl.render(function(err, data) {
          if (err) {
            return deferred.reject(Compiler._errors.styl(err, options.path));
          } else {
            return deferred.resolve(data);
          }
        });
        return deferred.promise;
      },
      eco: function(data, options) {
        if (options.minify === true && options.jquerify === true) {

        } else if (options.minify === true) {
          return Q.reject(new Error('Minifing eco templates is not implemented'));
        }
        if (options.precompile === true) {
          data = eco.precompile(data);
          if (options.jquerify === true) {
            data = Compiler._jquerify.precompiled(data);
          }
        } else {
          data = eco.render(data, options.data);
          if (options.jquerify === true) {
            data = Compiler._jquerify.compiled(data);
          }
        }
        return Q.resolve(data);
      }
    };

    Compiler._jquerify = {
      precompiled: function(data) {
        return "function (values, data) {\n					   var $ = jQuery, result = $();\n					   values = $.makeArray(values);\n					   data = data || {};\n					   for (var i=0; i < values.length; i++) {\n						   var value = $.extend({}, values[i], data, {index: i});\n						   var elem  = $((" + data + ")(value));\n						   elem.data('item', value);\n						   $.merge(result, elem);\n					   }\n					   return result;\n};";
      },
      compiled: function(data) {
        data = data.replace(/\'/g, "\\'");
        data = data.replace(/\n/g, "' +\n'");
        data = data.replace(/[\s\+]+$/, '');
        return "(function() {\n$('" + data + "');\n}).call(this);";
      }
    };

    Compiler._minify = {
      uglify: function(data) {
        return uglify.minify(data, {
          fromString: true
        }).code;
      },
      cleanCss: function(data) {
        return cleanCss.process(data);
      }
    };

    Compiler._errors = {
      coffee: function(err, path) {
        if (path == null) {
          path = null;
        }
        return err;
      },
      json: function(err, path) {
        if (path == null) {
          path = null;
        }
        return err;
      },
      js: function(err, path) {
        if (path == null) {
          path = null;
        }
        return err;
      },
      ts: function(err, path) {
        var e;
        if (path == null) {
          path = null;
        }
        e = new Error(err.message.replace(/^Command\sfailed\:\s/, ''));
        e.filename = path;
        return e;
      },
      less: function(err, path) {
        var e, msg;
        if (path == null) {
          path = null;
        }
        msg = err.type + 'Error: ' + err.message.replace(/[\s\.]+$/, '');
        msg += err.filename !== null ? " in " + err.filename + ":" : ' on line ';
        msg += "" + err.line + ":" + err.column;
        e = new Error(msg);
        e.type = err.type;
        e.filename = err.filename;
        e.line = err.line;
        e.column = err.column;
        return e;
      },
      scss: function(err, path) {
        var data, e, line, msg;
        if (path == null) {
          path = null;
        }
        data = err.message.split('\n')[0].match(/^\:(\d+)\:\serror\:\s(.*)/);
        line = data[1];
        msg = data[2];
        msg += path !== null ? " in " + path + ":" : ' on line ';
        msg += line;
        e = new Error(msg);
        e.type = err.name;
        e.filename = path;
        e.line = line;
        return e;
      },
      styl: function(err, path) {
        var data, e, line, msg;
        if (path == null) {
          path = null;
        }
        data = err.message.split('\n');
        line = data[0].split(':')[1];
        msg = data[data.length - 2];
        msg += path !== null ? " in " + path + ":" : ' on line ';
        msg += line;
        e = new Error(msg);
        e.filename = path;
        e.line = line;
        return e;
      }
    };

    return Compiler;

  }).call(this);

  module.exports = Compiler;

}).call(this);
