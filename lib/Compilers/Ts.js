// Generated by CoffeeScript 1.6.3
(function() {
  var CompileException, Compiler, Q, SyntaxException, Ts, exec, fs, path, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Q = require('q');

  path = require('path');

  exec = require('child_process').exec;

  fs = require('fs');

  Compiler = require('./Compiler');

  CompileException = require('../Exceptions/CompileException');

  SyntaxException = require('../Exceptions/SyntaxException');

  Ts = (function(_super) {
    __extends(Ts, _super);

    function Ts() {
      _ref = Ts.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    Ts.ESCAPE_PATTERN = ['.', '[', ']', '\\', '/', '^', '$', '|', '?', '+', '(', ')', '{', '}'];

    Ts.prototype.getMinifier = function() {
      return 'uglify';
    };

    Ts.prototype.parse = function(data, options) {
      var deferred, dir, fileName, name, ts,
        _this = this;
      if (options == null) {
        options = {};
      }
      if (options.path === null) {
        return Q.reject(new CompileException('You have to set path for compiling typescript.'));
      }
      deferred = Q.defer();
      dir = path.dirname(options.path);
      name = path.basename(options.path, path.extname(options.path));
      fileName = "" + dir + "/" + name + ".js";
      ts = path.resolve("" + __dirname + "/../../node_modules/typescript/bin/tsc.js");
      exec("node " + ts + " " + options.path, function(err, stdout, stderr) {
        if (err) {
          return deferred.reject(_this.parseError(err, options.path));
        } else {
          return fs.readFile(fileName, 'utf-8', function(err, content) {
            fs.unlink(fileName);
            if (err) {
              return deferred.reject(err);
            } else {
              return deferred.resolve(content);
            }
          });
        }
      });
      return deferred.promise;
    };

    Ts.prototype.parseError = function(error, _path) {
      var char, e, match, message, p, r, replace, _i, _len, _ref1;
      replace = [];
      _ref1 = Ts.ESCAPE_PATTERN;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        char = _ref1[_i];
        replace.push('\\' + char);
      }
      p = _path.replace(new RegExp('(' + replace.join('|') + ')', 'g'), '\\$1');
      message = error.message.replace(/\n$/, '');
      r = new RegExp('^Command\\sfailed\\:\\s' + p + '\\((\\d+)\\,(\\d+)\\)\\:\\serror\\sTS(\\d+)\\:\\s(.+)$');
      match = message.match(r);
      e = new SyntaxException(match[4]);
      e.filename = _path;
      e.line = parseInt(match[1]);
      e.column = parseInt(match[2]);
      e.code = parseInt(match[3]);
      return e;
    };

    return Ts;

  })(Compiler);

  module.exports = Ts;

}).call(this);
